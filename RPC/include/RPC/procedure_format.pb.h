// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: procedure_format.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_procedure_5fformat_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_procedure_5fformat_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_procedure_5fformat_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_procedure_5fformat_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_procedure_5fformat_2eproto;
namespace RPC {
class Argument;
struct ArgumentDefaultTypeInternal;
extern ArgumentDefaultTypeInternal _Argument_default_instance_;
class AuthRequest;
struct AuthRequestDefaultTypeInternal;
extern AuthRequestDefaultTypeInternal _AuthRequest_default_instance_;
class AuthResponse;
struct AuthResponseDefaultTypeInternal;
extern AuthResponseDefaultTypeInternal _AuthResponse_default_instance_;
class FunctionRequest;
struct FunctionRequestDefaultTypeInternal;
extern FunctionRequestDefaultTypeInternal _FunctionRequest_default_instance_;
class Request;
struct RequestDefaultTypeInternal;
extern RequestDefaultTypeInternal _Request_default_instance_;
class Response;
struct ResponseDefaultTypeInternal;
extern ResponseDefaultTypeInternal _Response_default_instance_;
class ReturnValue;
struct ReturnValueDefaultTypeInternal;
extern ReturnValueDefaultTypeInternal _ReturnValue_default_instance_;
}  // namespace RPC
PROTOBUF_NAMESPACE_OPEN
template<> ::RPC::Argument* Arena::CreateMaybeMessage<::RPC::Argument>(Arena*);
template<> ::RPC::AuthRequest* Arena::CreateMaybeMessage<::RPC::AuthRequest>(Arena*);
template<> ::RPC::AuthResponse* Arena::CreateMaybeMessage<::RPC::AuthResponse>(Arena*);
template<> ::RPC::FunctionRequest* Arena::CreateMaybeMessage<::RPC::FunctionRequest>(Arena*);
template<> ::RPC::Request* Arena::CreateMaybeMessage<::RPC::Request>(Arena*);
template<> ::RPC::Response* Arena::CreateMaybeMessage<::RPC::Response>(Arena*);
template<> ::RPC::ReturnValue* Arena::CreateMaybeMessage<::RPC::ReturnValue>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace RPC {

enum Status : int {
  OK = 0,
  ERROR = 1,
  INVALID_ARGUMENT = 2,
  NOT_FOUND = 3,
  PERMISSION_DENIED = 4,
  INTERNAL_ERROR = 5,
  Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Status_IsValid(int value);
constexpr Status Status_MIN = OK;
constexpr Status Status_MAX = INTERNAL_ERROR;
constexpr int Status_ARRAYSIZE = Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Status_descriptor();
template<typename T>
inline const std::string& Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Status_descriptor(), enum_t_value);
}
inline bool Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Status>(
    Status_descriptor(), name, value);
}
// ===================================================================

class Argument final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RPC.Argument) */ {
 public:
  inline Argument() : Argument(nullptr) {}
  ~Argument() override;
  explicit PROTOBUF_CONSTEXPR Argument(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Argument(const Argument& from);
  Argument(Argument&& from) noexcept
    : Argument() {
    *this = ::std::move(from);
  }

  inline Argument& operator=(const Argument& from) {
    CopyFrom(from);
    return *this;
  }
  inline Argument& operator=(Argument&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Argument& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kIntVal = 2,
    kDoubleVal = 3,
    kStringVal = 4,
    kBinaryVal = 5,
    kBoolVal = 6,
    VALUE_NOT_SET = 0,
  };

  static inline const Argument* internal_default_instance() {
    return reinterpret_cast<const Argument*>(
               &_Argument_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Argument& a, Argument& b) {
    a.Swap(&b);
  }
  inline void Swap(Argument* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Argument* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Argument* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Argument>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Argument& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Argument& from) {
    Argument::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Argument* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RPC.Argument";
  }
  protected:
  explicit Argument(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kIntValFieldNumber = 2,
    kDoubleValFieldNumber = 3,
    kStringValFieldNumber = 4,
    kBinaryValFieldNumber = 5,
    kBoolValFieldNumber = 6,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // int32 int_val = 2;
  bool has_int_val() const;
  private:
  bool _internal_has_int_val() const;
  public:
  void clear_int_val();
  int32_t int_val() const;
  void set_int_val(int32_t value);
  private:
  int32_t _internal_int_val() const;
  void _internal_set_int_val(int32_t value);
  public:

  // double double_val = 3;
  bool has_double_val() const;
  private:
  bool _internal_has_double_val() const;
  public:
  void clear_double_val();
  double double_val() const;
  void set_double_val(double value);
  private:
  double _internal_double_val() const;
  void _internal_set_double_val(double value);
  public:

  // string string_val = 4;
  bool has_string_val() const;
  private:
  bool _internal_has_string_val() const;
  public:
  void clear_string_val();
  const std::string& string_val() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_string_val(ArgT0&& arg0, ArgT... args);
  std::string* mutable_string_val();
  PROTOBUF_NODISCARD std::string* release_string_val();
  void set_allocated_string_val(std::string* string_val);
  private:
  const std::string& _internal_string_val() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_string_val(const std::string& value);
  std::string* _internal_mutable_string_val();
  public:

  // bytes binary_val = 5;
  bool has_binary_val() const;
  private:
  bool _internal_has_binary_val() const;
  public:
  void clear_binary_val();
  const std::string& binary_val() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_binary_val(ArgT0&& arg0, ArgT... args);
  std::string* mutable_binary_val();
  PROTOBUF_NODISCARD std::string* release_binary_val();
  void set_allocated_binary_val(std::string* binary_val);
  private:
  const std::string& _internal_binary_val() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_binary_val(const std::string& value);
  std::string* _internal_mutable_binary_val();
  public:

  // bool bool_val = 6;
  bool has_bool_val() const;
  private:
  bool _internal_has_bool_val() const;
  public:
  void clear_bool_val();
  bool bool_val() const;
  void set_bool_val(bool value);
  private:
  bool _internal_bool_val() const;
  void _internal_set_bool_val(bool value);
  public:

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:RPC.Argument)
 private:
  class _Internal;
  void set_has_int_val();
  void set_has_double_val();
  void set_has_string_val();
  void set_has_binary_val();
  void set_has_bool_val();

  inline bool has_value() const;
  inline void clear_has_value();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    union ValueUnion {
      constexpr ValueUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      int32_t int_val_;
      double double_val_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr string_val_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr binary_val_;
      bool bool_val_;
    } value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_procedure_5fformat_2eproto;
};
// -------------------------------------------------------------------

class ReturnValue final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RPC.ReturnValue) */ {
 public:
  inline ReturnValue() : ReturnValue(nullptr) {}
  ~ReturnValue() override;
  explicit PROTOBUF_CONSTEXPR ReturnValue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReturnValue(const ReturnValue& from);
  ReturnValue(ReturnValue&& from) noexcept
    : ReturnValue() {
    *this = ::std::move(from);
  }

  inline ReturnValue& operator=(const ReturnValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReturnValue& operator=(ReturnValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReturnValue& default_instance() {
    return *internal_default_instance();
  }
  enum ResultCase {
    kIntResult = 3,
    kDoubleResult = 4,
    kStringResult = 5,
    kBinaryResult = 6,
    kBoolResult = 7,
    RESULT_NOT_SET = 0,
  };

  static inline const ReturnValue* internal_default_instance() {
    return reinterpret_cast<const ReturnValue*>(
               &_ReturnValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ReturnValue& a, ReturnValue& b) {
    a.Swap(&b);
  }
  inline void Swap(ReturnValue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReturnValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReturnValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReturnValue>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReturnValue& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReturnValue& from) {
    ReturnValue::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReturnValue* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RPC.ReturnValue";
  }
  protected:
  explicit ReturnValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kStatusFieldNumber = 1,
    kIntResultFieldNumber = 3,
    kDoubleResultFieldNumber = 4,
    kStringResultFieldNumber = 5,
    kBinaryResultFieldNumber = 6,
    kBoolResultFieldNumber = 7,
  };
  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .RPC.Status status = 1;
  void clear_status();
  ::RPC::Status status() const;
  void set_status(::RPC::Status value);
  private:
  ::RPC::Status _internal_status() const;
  void _internal_set_status(::RPC::Status value);
  public:

  // int32 int_result = 3;
  bool has_int_result() const;
  private:
  bool _internal_has_int_result() const;
  public:
  void clear_int_result();
  int32_t int_result() const;
  void set_int_result(int32_t value);
  private:
  int32_t _internal_int_result() const;
  void _internal_set_int_result(int32_t value);
  public:

  // double double_result = 4;
  bool has_double_result() const;
  private:
  bool _internal_has_double_result() const;
  public:
  void clear_double_result();
  double double_result() const;
  void set_double_result(double value);
  private:
  double _internal_double_result() const;
  void _internal_set_double_result(double value);
  public:

  // string string_result = 5;
  bool has_string_result() const;
  private:
  bool _internal_has_string_result() const;
  public:
  void clear_string_result();
  const std::string& string_result() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_string_result(ArgT0&& arg0, ArgT... args);
  std::string* mutable_string_result();
  PROTOBUF_NODISCARD std::string* release_string_result();
  void set_allocated_string_result(std::string* string_result);
  private:
  const std::string& _internal_string_result() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_string_result(const std::string& value);
  std::string* _internal_mutable_string_result();
  public:

  // bytes binary_result = 6;
  bool has_binary_result() const;
  private:
  bool _internal_has_binary_result() const;
  public:
  void clear_binary_result();
  const std::string& binary_result() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_binary_result(ArgT0&& arg0, ArgT... args);
  std::string* mutable_binary_result();
  PROTOBUF_NODISCARD std::string* release_binary_result();
  void set_allocated_binary_result(std::string* binary_result);
  private:
  const std::string& _internal_binary_result() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_binary_result(const std::string& value);
  std::string* _internal_mutable_binary_result();
  public:

  // bool bool_result = 7;
  bool has_bool_result() const;
  private:
  bool _internal_has_bool_result() const;
  public:
  void clear_bool_result();
  bool bool_result() const;
  void set_bool_result(bool value);
  private:
  bool _internal_bool_result() const;
  void _internal_set_bool_result(bool value);
  public:

  void clear_result();
  ResultCase result_case() const;
  // @@protoc_insertion_point(class_scope:RPC.ReturnValue)
 private:
  class _Internal;
  void set_has_int_result();
  void set_has_double_result();
  void set_has_string_result();
  void set_has_binary_result();
  void set_has_bool_result();

  inline bool has_result() const;
  inline void clear_has_result();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    int status_;
    union ResultUnion {
      constexpr ResultUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      int32_t int_result_;
      double double_result_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr string_result_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr binary_result_;
      bool bool_result_;
    } result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_procedure_5fformat_2eproto;
};
// -------------------------------------------------------------------

class Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RPC.Request) */ {
 public:
  inline Request() : Request(nullptr) {}
  ~Request() override;
  explicit PROTOBUF_CONSTEXPR Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Request(const Request& from);
  Request(Request&& from) noexcept
    : Request() {
    *this = ::std::move(from);
  }

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline Request& operator=(Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Request& default_instance() {
    return *internal_default_instance();
  }
  enum RequestTypeCase {
    kAuthRequest = 1,
    kFunctionRequest = 2,
    REQUEST_TYPE_NOT_SET = 0,
  };

  static inline const Request* internal_default_instance() {
    return reinterpret_cast<const Request*>(
               &_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Request& a, Request& b) {
    a.Swap(&b);
  }
  inline void Swap(Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Request& from) {
    Request::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RPC.Request";
  }
  protected:
  explicit Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAuthRequestFieldNumber = 1,
    kFunctionRequestFieldNumber = 2,
  };
  // .RPC.AuthRequest auth_request = 1;
  bool has_auth_request() const;
  private:
  bool _internal_has_auth_request() const;
  public:
  void clear_auth_request();
  const ::RPC::AuthRequest& auth_request() const;
  PROTOBUF_NODISCARD ::RPC::AuthRequest* release_auth_request();
  ::RPC::AuthRequest* mutable_auth_request();
  void set_allocated_auth_request(::RPC::AuthRequest* auth_request);
  private:
  const ::RPC::AuthRequest& _internal_auth_request() const;
  ::RPC::AuthRequest* _internal_mutable_auth_request();
  public:
  void unsafe_arena_set_allocated_auth_request(
      ::RPC::AuthRequest* auth_request);
  ::RPC::AuthRequest* unsafe_arena_release_auth_request();

  // .RPC.FunctionRequest function_request = 2;
  bool has_function_request() const;
  private:
  bool _internal_has_function_request() const;
  public:
  void clear_function_request();
  const ::RPC::FunctionRequest& function_request() const;
  PROTOBUF_NODISCARD ::RPC::FunctionRequest* release_function_request();
  ::RPC::FunctionRequest* mutable_function_request();
  void set_allocated_function_request(::RPC::FunctionRequest* function_request);
  private:
  const ::RPC::FunctionRequest& _internal_function_request() const;
  ::RPC::FunctionRequest* _internal_mutable_function_request();
  public:
  void unsafe_arena_set_allocated_function_request(
      ::RPC::FunctionRequest* function_request);
  ::RPC::FunctionRequest* unsafe_arena_release_function_request();

  void clear_request_type();
  RequestTypeCase request_type_case() const;
  // @@protoc_insertion_point(class_scope:RPC.Request)
 private:
  class _Internal;
  void set_has_auth_request();
  void set_has_function_request();

  inline bool has_request_type() const;
  inline void clear_has_request_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union RequestTypeUnion {
      constexpr RequestTypeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::RPC::AuthRequest* auth_request_;
      ::RPC::FunctionRequest* function_request_;
    } request_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_procedure_5fformat_2eproto;
};
// -------------------------------------------------------------------

class FunctionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RPC.FunctionRequest) */ {
 public:
  inline FunctionRequest() : FunctionRequest(nullptr) {}
  ~FunctionRequest() override;
  explicit PROTOBUF_CONSTEXPR FunctionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FunctionRequest(const FunctionRequest& from);
  FunctionRequest(FunctionRequest&& from) noexcept
    : FunctionRequest() {
    *this = ::std::move(from);
  }

  inline FunctionRequest& operator=(const FunctionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FunctionRequest& operator=(FunctionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FunctionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FunctionRequest* internal_default_instance() {
    return reinterpret_cast<const FunctionRequest*>(
               &_FunctionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(FunctionRequest& a, FunctionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FunctionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FunctionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FunctionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FunctionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FunctionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FunctionRequest& from) {
    FunctionRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FunctionRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RPC.FunctionRequest";
  }
  protected:
  explicit FunctionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArgsFieldNumber = 2,
    kFunctionNameFieldNumber = 1,
    kClientIdFieldNumber = 3,
    kTokenFieldNumber = 4,
  };
  // repeated .RPC.Argument args = 2;
  int args_size() const;
  private:
  int _internal_args_size() const;
  public:
  void clear_args();
  ::RPC::Argument* mutable_args(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RPC::Argument >*
      mutable_args();
  private:
  const ::RPC::Argument& _internal_args(int index) const;
  ::RPC::Argument* _internal_add_args();
  public:
  const ::RPC::Argument& args(int index) const;
  ::RPC::Argument* add_args();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RPC::Argument >&
      args() const;

  // string function_name = 1;
  void clear_function_name();
  const std::string& function_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_function_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_function_name();
  PROTOBUF_NODISCARD std::string* release_function_name();
  void set_allocated_function_name(std::string* function_name);
  private:
  const std::string& _internal_function_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_function_name(const std::string& value);
  std::string* _internal_mutable_function_name();
  public:

  // string client_id = 3;
  void clear_client_id();
  const std::string& client_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_client_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_client_id();
  PROTOBUF_NODISCARD std::string* release_client_id();
  void set_allocated_client_id(std::string* client_id);
  private:
  const std::string& _internal_client_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_id(const std::string& value);
  std::string* _internal_mutable_client_id();
  public:

  // string token = 4;
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // @@protoc_insertion_point(class_scope:RPC.FunctionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RPC::Argument > args_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr function_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_procedure_5fformat_2eproto;
};
// -------------------------------------------------------------------

class Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RPC.Response) */ {
 public:
  inline Response() : Response(nullptr) {}
  ~Response() override;
  explicit PROTOBUF_CONSTEXPR Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Response(const Response& from);
  Response(Response&& from) noexcept
    : Response() {
    *this = ::std::move(from);
  }

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline Response& operator=(Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Response& default_instance() {
    return *internal_default_instance();
  }
  enum ResponseTypeCase {
    kReturnValue = 1,
    kAuthResponse = 2,
    RESPONSE_TYPE_NOT_SET = 0,
  };

  static inline const Response* internal_default_instance() {
    return reinterpret_cast<const Response*>(
               &_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Response& a, Response& b) {
    a.Swap(&b);
  }
  inline void Swap(Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Response& from) {
    Response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RPC.Response";
  }
  protected:
  explicit Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReturnValueFieldNumber = 1,
    kAuthResponseFieldNumber = 2,
  };
  // .RPC.ReturnValue return_value = 1;
  bool has_return_value() const;
  private:
  bool _internal_has_return_value() const;
  public:
  void clear_return_value();
  const ::RPC::ReturnValue& return_value() const;
  PROTOBUF_NODISCARD ::RPC::ReturnValue* release_return_value();
  ::RPC::ReturnValue* mutable_return_value();
  void set_allocated_return_value(::RPC::ReturnValue* return_value);
  private:
  const ::RPC::ReturnValue& _internal_return_value() const;
  ::RPC::ReturnValue* _internal_mutable_return_value();
  public:
  void unsafe_arena_set_allocated_return_value(
      ::RPC::ReturnValue* return_value);
  ::RPC::ReturnValue* unsafe_arena_release_return_value();

  // .RPC.AuthResponse auth_response = 2;
  bool has_auth_response() const;
  private:
  bool _internal_has_auth_response() const;
  public:
  void clear_auth_response();
  const ::RPC::AuthResponse& auth_response() const;
  PROTOBUF_NODISCARD ::RPC::AuthResponse* release_auth_response();
  ::RPC::AuthResponse* mutable_auth_response();
  void set_allocated_auth_response(::RPC::AuthResponse* auth_response);
  private:
  const ::RPC::AuthResponse& _internal_auth_response() const;
  ::RPC::AuthResponse* _internal_mutable_auth_response();
  public:
  void unsafe_arena_set_allocated_auth_response(
      ::RPC::AuthResponse* auth_response);
  ::RPC::AuthResponse* unsafe_arena_release_auth_response();

  void clear_response_type();
  ResponseTypeCase response_type_case() const;
  // @@protoc_insertion_point(class_scope:RPC.Response)
 private:
  class _Internal;
  void set_has_return_value();
  void set_has_auth_response();

  inline bool has_response_type() const;
  inline void clear_has_response_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ResponseTypeUnion {
      constexpr ResponseTypeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::RPC::ReturnValue* return_value_;
      ::RPC::AuthResponse* auth_response_;
    } response_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_procedure_5fformat_2eproto;
};
// -------------------------------------------------------------------

class AuthRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RPC.AuthRequest) */ {
 public:
  inline AuthRequest() : AuthRequest(nullptr) {}
  ~AuthRequest() override;
  explicit PROTOBUF_CONSTEXPR AuthRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthRequest(const AuthRequest& from);
  AuthRequest(AuthRequest&& from) noexcept
    : AuthRequest() {
    *this = ::std::move(from);
  }

  inline AuthRequest& operator=(const AuthRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthRequest& operator=(AuthRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthRequest* internal_default_instance() {
    return reinterpret_cast<const AuthRequest*>(
               &_AuthRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(AuthRequest& a, AuthRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuthRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AuthRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AuthRequest& from) {
    AuthRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RPC.AuthRequest";
  }
  protected:
  explicit AuthRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientIdFieldNumber = 1,
    kClientSecretFieldNumber = 2,
    kUidFieldNumber = 3,
    kGidFieldNumber = 4,
  };
  // string client_id = 1;
  void clear_client_id();
  const std::string& client_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_client_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_client_id();
  PROTOBUF_NODISCARD std::string* release_client_id();
  void set_allocated_client_id(std::string* client_id);
  private:
  const std::string& _internal_client_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_id(const std::string& value);
  std::string* _internal_mutable_client_id();
  public:

  // string client_secret = 2;
  void clear_client_secret();
  const std::string& client_secret() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_client_secret(ArgT0&& arg0, ArgT... args);
  std::string* mutable_client_secret();
  PROTOBUF_NODISCARD std::string* release_client_secret();
  void set_allocated_client_secret(std::string* client_secret);
  private:
  const std::string& _internal_client_secret() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_secret(const std::string& value);
  std::string* _internal_mutable_client_secret();
  public:

  // int32 uid = 3;
  void clear_uid();
  int32_t uid() const;
  void set_uid(int32_t value);
  private:
  int32_t _internal_uid() const;
  void _internal_set_uid(int32_t value);
  public:

  // int32 gid = 4;
  void clear_gid();
  int32_t gid() const;
  void set_gid(int32_t value);
  private:
  int32_t _internal_gid() const;
  void _internal_set_gid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:RPC.AuthRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_secret_;
    int32_t uid_;
    int32_t gid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_procedure_5fformat_2eproto;
};
// -------------------------------------------------------------------

class AuthResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RPC.AuthResponse) */ {
 public:
  inline AuthResponse() : AuthResponse(nullptr) {}
  ~AuthResponse() override;
  explicit PROTOBUF_CONSTEXPR AuthResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthResponse(const AuthResponse& from);
  AuthResponse(AuthResponse&& from) noexcept
    : AuthResponse() {
    *this = ::std::move(from);
  }

  inline AuthResponse& operator=(const AuthResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthResponse& operator=(AuthResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthResponse* internal_default_instance() {
    return reinterpret_cast<const AuthResponse*>(
               &_AuthResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(AuthResponse& a, AuthResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuthResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AuthResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AuthResponse& from) {
    AuthResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RPC.AuthResponse";
  }
  protected:
  explicit AuthResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 2,
    kMessageFieldNumber = 3,
    kSessionExpiryFieldNumber = 4,
    kStatusFieldNumber = 1,
  };
  // string token = 2;
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // string message = 3;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // int64 session_expiry = 4;
  void clear_session_expiry();
  int64_t session_expiry() const;
  void set_session_expiry(int64_t value);
  private:
  int64_t _internal_session_expiry() const;
  void _internal_set_session_expiry(int64_t value);
  public:

  // .RPC.Status status = 1;
  void clear_status();
  ::RPC::Status status() const;
  void set_status(::RPC::Status value);
  private:
  ::RPC::Status _internal_status() const;
  void _internal_set_status(::RPC::Status value);
  public:

  // @@protoc_insertion_point(class_scope:RPC.AuthResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    int64_t session_expiry_;
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_procedure_5fformat_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Argument

// string name = 1;
inline void Argument::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Argument::name() const {
  // @@protoc_insertion_point(field_get:RPC.Argument.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Argument::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RPC.Argument.name)
}
inline std::string* Argument::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:RPC.Argument.name)
  return _s;
}
inline const std::string& Argument::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Argument::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Argument::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Argument::release_name() {
  // @@protoc_insertion_point(field_release:RPC.Argument.name)
  return _impl_.name_.Release();
}
inline void Argument::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RPC.Argument.name)
}

// int32 int_val = 2;
inline bool Argument::_internal_has_int_val() const {
  return value_case() == kIntVal;
}
inline bool Argument::has_int_val() const {
  return _internal_has_int_val();
}
inline void Argument::set_has_int_val() {
  _impl_._oneof_case_[0] = kIntVal;
}
inline void Argument::clear_int_val() {
  if (_internal_has_int_val()) {
    _impl_.value_.int_val_ = 0;
    clear_has_value();
  }
}
inline int32_t Argument::_internal_int_val() const {
  if (_internal_has_int_val()) {
    return _impl_.value_.int_val_;
  }
  return 0;
}
inline void Argument::_internal_set_int_val(int32_t value) {
  if (!_internal_has_int_val()) {
    clear_value();
    set_has_int_val();
  }
  _impl_.value_.int_val_ = value;
}
inline int32_t Argument::int_val() const {
  // @@protoc_insertion_point(field_get:RPC.Argument.int_val)
  return _internal_int_val();
}
inline void Argument::set_int_val(int32_t value) {
  _internal_set_int_val(value);
  // @@protoc_insertion_point(field_set:RPC.Argument.int_val)
}

// double double_val = 3;
inline bool Argument::_internal_has_double_val() const {
  return value_case() == kDoubleVal;
}
inline bool Argument::has_double_val() const {
  return _internal_has_double_val();
}
inline void Argument::set_has_double_val() {
  _impl_._oneof_case_[0] = kDoubleVal;
}
inline void Argument::clear_double_val() {
  if (_internal_has_double_val()) {
    _impl_.value_.double_val_ = 0;
    clear_has_value();
  }
}
inline double Argument::_internal_double_val() const {
  if (_internal_has_double_val()) {
    return _impl_.value_.double_val_;
  }
  return 0;
}
inline void Argument::_internal_set_double_val(double value) {
  if (!_internal_has_double_val()) {
    clear_value();
    set_has_double_val();
  }
  _impl_.value_.double_val_ = value;
}
inline double Argument::double_val() const {
  // @@protoc_insertion_point(field_get:RPC.Argument.double_val)
  return _internal_double_val();
}
inline void Argument::set_double_val(double value) {
  _internal_set_double_val(value);
  // @@protoc_insertion_point(field_set:RPC.Argument.double_val)
}

// string string_val = 4;
inline bool Argument::_internal_has_string_val() const {
  return value_case() == kStringVal;
}
inline bool Argument::has_string_val() const {
  return _internal_has_string_val();
}
inline void Argument::set_has_string_val() {
  _impl_._oneof_case_[0] = kStringVal;
}
inline void Argument::clear_string_val() {
  if (_internal_has_string_val()) {
    _impl_.value_.string_val_.Destroy();
    clear_has_value();
  }
}
inline const std::string& Argument::string_val() const {
  // @@protoc_insertion_point(field_get:RPC.Argument.string_val)
  return _internal_string_val();
}
template <typename ArgT0, typename... ArgT>
inline void Argument::set_string_val(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_string_val()) {
    clear_value();
    set_has_string_val();
    _impl_.value_.string_val_.InitDefault();
  }
  _impl_.value_.string_val_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RPC.Argument.string_val)
}
inline std::string* Argument::mutable_string_val() {
  std::string* _s = _internal_mutable_string_val();
  // @@protoc_insertion_point(field_mutable:RPC.Argument.string_val)
  return _s;
}
inline const std::string& Argument::_internal_string_val() const {
  if (_internal_has_string_val()) {
    return _impl_.value_.string_val_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Argument::_internal_set_string_val(const std::string& value) {
  if (!_internal_has_string_val()) {
    clear_value();
    set_has_string_val();
    _impl_.value_.string_val_.InitDefault();
  }
  _impl_.value_.string_val_.Set(value, GetArenaForAllocation());
}
inline std::string* Argument::_internal_mutable_string_val() {
  if (!_internal_has_string_val()) {
    clear_value();
    set_has_string_val();
    _impl_.value_.string_val_.InitDefault();
  }
  return _impl_.value_.string_val_.Mutable(      GetArenaForAllocation());
}
inline std::string* Argument::release_string_val() {
  // @@protoc_insertion_point(field_release:RPC.Argument.string_val)
  if (_internal_has_string_val()) {
    clear_has_value();
    return _impl_.value_.string_val_.Release();
  } else {
    return nullptr;
  }
}
inline void Argument::set_allocated_string_val(std::string* string_val) {
  if (has_value()) {
    clear_value();
  }
  if (string_val != nullptr) {
    set_has_string_val();
    _impl_.value_.string_val_.InitAllocated(string_val, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:RPC.Argument.string_val)
}

// bytes binary_val = 5;
inline bool Argument::_internal_has_binary_val() const {
  return value_case() == kBinaryVal;
}
inline bool Argument::has_binary_val() const {
  return _internal_has_binary_val();
}
inline void Argument::set_has_binary_val() {
  _impl_._oneof_case_[0] = kBinaryVal;
}
inline void Argument::clear_binary_val() {
  if (_internal_has_binary_val()) {
    _impl_.value_.binary_val_.Destroy();
    clear_has_value();
  }
}
inline const std::string& Argument::binary_val() const {
  // @@protoc_insertion_point(field_get:RPC.Argument.binary_val)
  return _internal_binary_val();
}
template <typename ArgT0, typename... ArgT>
inline void Argument::set_binary_val(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_binary_val()) {
    clear_value();
    set_has_binary_val();
    _impl_.value_.binary_val_.InitDefault();
  }
  _impl_.value_.binary_val_.SetBytes( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RPC.Argument.binary_val)
}
inline std::string* Argument::mutable_binary_val() {
  std::string* _s = _internal_mutable_binary_val();
  // @@protoc_insertion_point(field_mutable:RPC.Argument.binary_val)
  return _s;
}
inline const std::string& Argument::_internal_binary_val() const {
  if (_internal_has_binary_val()) {
    return _impl_.value_.binary_val_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Argument::_internal_set_binary_val(const std::string& value) {
  if (!_internal_has_binary_val()) {
    clear_value();
    set_has_binary_val();
    _impl_.value_.binary_val_.InitDefault();
  }
  _impl_.value_.binary_val_.Set(value, GetArenaForAllocation());
}
inline std::string* Argument::_internal_mutable_binary_val() {
  if (!_internal_has_binary_val()) {
    clear_value();
    set_has_binary_val();
    _impl_.value_.binary_val_.InitDefault();
  }
  return _impl_.value_.binary_val_.Mutable(      GetArenaForAllocation());
}
inline std::string* Argument::release_binary_val() {
  // @@protoc_insertion_point(field_release:RPC.Argument.binary_val)
  if (_internal_has_binary_val()) {
    clear_has_value();
    return _impl_.value_.binary_val_.Release();
  } else {
    return nullptr;
  }
}
inline void Argument::set_allocated_binary_val(std::string* binary_val) {
  if (has_value()) {
    clear_value();
  }
  if (binary_val != nullptr) {
    set_has_binary_val();
    _impl_.value_.binary_val_.InitAllocated(binary_val, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:RPC.Argument.binary_val)
}

// bool bool_val = 6;
inline bool Argument::_internal_has_bool_val() const {
  return value_case() == kBoolVal;
}
inline bool Argument::has_bool_val() const {
  return _internal_has_bool_val();
}
inline void Argument::set_has_bool_val() {
  _impl_._oneof_case_[0] = kBoolVal;
}
inline void Argument::clear_bool_val() {
  if (_internal_has_bool_val()) {
    _impl_.value_.bool_val_ = false;
    clear_has_value();
  }
}
inline bool Argument::_internal_bool_val() const {
  if (_internal_has_bool_val()) {
    return _impl_.value_.bool_val_;
  }
  return false;
}
inline void Argument::_internal_set_bool_val(bool value) {
  if (!_internal_has_bool_val()) {
    clear_value();
    set_has_bool_val();
  }
  _impl_.value_.bool_val_ = value;
}
inline bool Argument::bool_val() const {
  // @@protoc_insertion_point(field_get:RPC.Argument.bool_val)
  return _internal_bool_val();
}
inline void Argument::set_bool_val(bool value) {
  _internal_set_bool_val(value);
  // @@protoc_insertion_point(field_set:RPC.Argument.bool_val)
}

inline bool Argument::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void Argument::clear_has_value() {
  _impl_._oneof_case_[0] = VALUE_NOT_SET;
}
inline Argument::ValueCase Argument::value_case() const {
  return Argument::ValueCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ReturnValue

// .RPC.Status status = 1;
inline void ReturnValue::clear_status() {
  _impl_.status_ = 0;
}
inline ::RPC::Status ReturnValue::_internal_status() const {
  return static_cast< ::RPC::Status >(_impl_.status_);
}
inline ::RPC::Status ReturnValue::status() const {
  // @@protoc_insertion_point(field_get:RPC.ReturnValue.status)
  return _internal_status();
}
inline void ReturnValue::_internal_set_status(::RPC::Status value) {
  
  _impl_.status_ = value;
}
inline void ReturnValue::set_status(::RPC::Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:RPC.ReturnValue.status)
}

// string message = 2;
inline void ReturnValue::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& ReturnValue::message() const {
  // @@protoc_insertion_point(field_get:RPC.ReturnValue.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReturnValue::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RPC.ReturnValue.message)
}
inline std::string* ReturnValue::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:RPC.ReturnValue.message)
  return _s;
}
inline const std::string& ReturnValue::_internal_message() const {
  return _impl_.message_.Get();
}
inline void ReturnValue::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* ReturnValue::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* ReturnValue::release_message() {
  // @@protoc_insertion_point(field_release:RPC.ReturnValue.message)
  return _impl_.message_.Release();
}
inline void ReturnValue::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RPC.ReturnValue.message)
}

// int32 int_result = 3;
inline bool ReturnValue::_internal_has_int_result() const {
  return result_case() == kIntResult;
}
inline bool ReturnValue::has_int_result() const {
  return _internal_has_int_result();
}
inline void ReturnValue::set_has_int_result() {
  _impl_._oneof_case_[0] = kIntResult;
}
inline void ReturnValue::clear_int_result() {
  if (_internal_has_int_result()) {
    _impl_.result_.int_result_ = 0;
    clear_has_result();
  }
}
inline int32_t ReturnValue::_internal_int_result() const {
  if (_internal_has_int_result()) {
    return _impl_.result_.int_result_;
  }
  return 0;
}
inline void ReturnValue::_internal_set_int_result(int32_t value) {
  if (!_internal_has_int_result()) {
    clear_result();
    set_has_int_result();
  }
  _impl_.result_.int_result_ = value;
}
inline int32_t ReturnValue::int_result() const {
  // @@protoc_insertion_point(field_get:RPC.ReturnValue.int_result)
  return _internal_int_result();
}
inline void ReturnValue::set_int_result(int32_t value) {
  _internal_set_int_result(value);
  // @@protoc_insertion_point(field_set:RPC.ReturnValue.int_result)
}

// double double_result = 4;
inline bool ReturnValue::_internal_has_double_result() const {
  return result_case() == kDoubleResult;
}
inline bool ReturnValue::has_double_result() const {
  return _internal_has_double_result();
}
inline void ReturnValue::set_has_double_result() {
  _impl_._oneof_case_[0] = kDoubleResult;
}
inline void ReturnValue::clear_double_result() {
  if (_internal_has_double_result()) {
    _impl_.result_.double_result_ = 0;
    clear_has_result();
  }
}
inline double ReturnValue::_internal_double_result() const {
  if (_internal_has_double_result()) {
    return _impl_.result_.double_result_;
  }
  return 0;
}
inline void ReturnValue::_internal_set_double_result(double value) {
  if (!_internal_has_double_result()) {
    clear_result();
    set_has_double_result();
  }
  _impl_.result_.double_result_ = value;
}
inline double ReturnValue::double_result() const {
  // @@protoc_insertion_point(field_get:RPC.ReturnValue.double_result)
  return _internal_double_result();
}
inline void ReturnValue::set_double_result(double value) {
  _internal_set_double_result(value);
  // @@protoc_insertion_point(field_set:RPC.ReturnValue.double_result)
}

// string string_result = 5;
inline bool ReturnValue::_internal_has_string_result() const {
  return result_case() == kStringResult;
}
inline bool ReturnValue::has_string_result() const {
  return _internal_has_string_result();
}
inline void ReturnValue::set_has_string_result() {
  _impl_._oneof_case_[0] = kStringResult;
}
inline void ReturnValue::clear_string_result() {
  if (_internal_has_string_result()) {
    _impl_.result_.string_result_.Destroy();
    clear_has_result();
  }
}
inline const std::string& ReturnValue::string_result() const {
  // @@protoc_insertion_point(field_get:RPC.ReturnValue.string_result)
  return _internal_string_result();
}
template <typename ArgT0, typename... ArgT>
inline void ReturnValue::set_string_result(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_string_result()) {
    clear_result();
    set_has_string_result();
    _impl_.result_.string_result_.InitDefault();
  }
  _impl_.result_.string_result_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RPC.ReturnValue.string_result)
}
inline std::string* ReturnValue::mutable_string_result() {
  std::string* _s = _internal_mutable_string_result();
  // @@protoc_insertion_point(field_mutable:RPC.ReturnValue.string_result)
  return _s;
}
inline const std::string& ReturnValue::_internal_string_result() const {
  if (_internal_has_string_result()) {
    return _impl_.result_.string_result_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void ReturnValue::_internal_set_string_result(const std::string& value) {
  if (!_internal_has_string_result()) {
    clear_result();
    set_has_string_result();
    _impl_.result_.string_result_.InitDefault();
  }
  _impl_.result_.string_result_.Set(value, GetArenaForAllocation());
}
inline std::string* ReturnValue::_internal_mutable_string_result() {
  if (!_internal_has_string_result()) {
    clear_result();
    set_has_string_result();
    _impl_.result_.string_result_.InitDefault();
  }
  return _impl_.result_.string_result_.Mutable(      GetArenaForAllocation());
}
inline std::string* ReturnValue::release_string_result() {
  // @@protoc_insertion_point(field_release:RPC.ReturnValue.string_result)
  if (_internal_has_string_result()) {
    clear_has_result();
    return _impl_.result_.string_result_.Release();
  } else {
    return nullptr;
  }
}
inline void ReturnValue::set_allocated_string_result(std::string* string_result) {
  if (has_result()) {
    clear_result();
  }
  if (string_result != nullptr) {
    set_has_string_result();
    _impl_.result_.string_result_.InitAllocated(string_result, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:RPC.ReturnValue.string_result)
}

// bytes binary_result = 6;
inline bool ReturnValue::_internal_has_binary_result() const {
  return result_case() == kBinaryResult;
}
inline bool ReturnValue::has_binary_result() const {
  return _internal_has_binary_result();
}
inline void ReturnValue::set_has_binary_result() {
  _impl_._oneof_case_[0] = kBinaryResult;
}
inline void ReturnValue::clear_binary_result() {
  if (_internal_has_binary_result()) {
    _impl_.result_.binary_result_.Destroy();
    clear_has_result();
  }
}
inline const std::string& ReturnValue::binary_result() const {
  // @@protoc_insertion_point(field_get:RPC.ReturnValue.binary_result)
  return _internal_binary_result();
}
template <typename ArgT0, typename... ArgT>
inline void ReturnValue::set_binary_result(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_binary_result()) {
    clear_result();
    set_has_binary_result();
    _impl_.result_.binary_result_.InitDefault();
  }
  _impl_.result_.binary_result_.SetBytes( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RPC.ReturnValue.binary_result)
}
inline std::string* ReturnValue::mutable_binary_result() {
  std::string* _s = _internal_mutable_binary_result();
  // @@protoc_insertion_point(field_mutable:RPC.ReturnValue.binary_result)
  return _s;
}
inline const std::string& ReturnValue::_internal_binary_result() const {
  if (_internal_has_binary_result()) {
    return _impl_.result_.binary_result_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void ReturnValue::_internal_set_binary_result(const std::string& value) {
  if (!_internal_has_binary_result()) {
    clear_result();
    set_has_binary_result();
    _impl_.result_.binary_result_.InitDefault();
  }
  _impl_.result_.binary_result_.Set(value, GetArenaForAllocation());
}
inline std::string* ReturnValue::_internal_mutable_binary_result() {
  if (!_internal_has_binary_result()) {
    clear_result();
    set_has_binary_result();
    _impl_.result_.binary_result_.InitDefault();
  }
  return _impl_.result_.binary_result_.Mutable(      GetArenaForAllocation());
}
inline std::string* ReturnValue::release_binary_result() {
  // @@protoc_insertion_point(field_release:RPC.ReturnValue.binary_result)
  if (_internal_has_binary_result()) {
    clear_has_result();
    return _impl_.result_.binary_result_.Release();
  } else {
    return nullptr;
  }
}
inline void ReturnValue::set_allocated_binary_result(std::string* binary_result) {
  if (has_result()) {
    clear_result();
  }
  if (binary_result != nullptr) {
    set_has_binary_result();
    _impl_.result_.binary_result_.InitAllocated(binary_result, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:RPC.ReturnValue.binary_result)
}

// bool bool_result = 7;
inline bool ReturnValue::_internal_has_bool_result() const {
  return result_case() == kBoolResult;
}
inline bool ReturnValue::has_bool_result() const {
  return _internal_has_bool_result();
}
inline void ReturnValue::set_has_bool_result() {
  _impl_._oneof_case_[0] = kBoolResult;
}
inline void ReturnValue::clear_bool_result() {
  if (_internal_has_bool_result()) {
    _impl_.result_.bool_result_ = false;
    clear_has_result();
  }
}
inline bool ReturnValue::_internal_bool_result() const {
  if (_internal_has_bool_result()) {
    return _impl_.result_.bool_result_;
  }
  return false;
}
inline void ReturnValue::_internal_set_bool_result(bool value) {
  if (!_internal_has_bool_result()) {
    clear_result();
    set_has_bool_result();
  }
  _impl_.result_.bool_result_ = value;
}
inline bool ReturnValue::bool_result() const {
  // @@protoc_insertion_point(field_get:RPC.ReturnValue.bool_result)
  return _internal_bool_result();
}
inline void ReturnValue::set_bool_result(bool value) {
  _internal_set_bool_result(value);
  // @@protoc_insertion_point(field_set:RPC.ReturnValue.bool_result)
}

inline bool ReturnValue::has_result() const {
  return result_case() != RESULT_NOT_SET;
}
inline void ReturnValue::clear_has_result() {
  _impl_._oneof_case_[0] = RESULT_NOT_SET;
}
inline ReturnValue::ResultCase ReturnValue::result_case() const {
  return ReturnValue::ResultCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Request

// .RPC.AuthRequest auth_request = 1;
inline bool Request::_internal_has_auth_request() const {
  return request_type_case() == kAuthRequest;
}
inline bool Request::has_auth_request() const {
  return _internal_has_auth_request();
}
inline void Request::set_has_auth_request() {
  _impl_._oneof_case_[0] = kAuthRequest;
}
inline void Request::clear_auth_request() {
  if (_internal_has_auth_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.request_type_.auth_request_;
    }
    clear_has_request_type();
  }
}
inline ::RPC::AuthRequest* Request::release_auth_request() {
  // @@protoc_insertion_point(field_release:RPC.Request.auth_request)
  if (_internal_has_auth_request()) {
    clear_has_request_type();
    ::RPC::AuthRequest* temp = _impl_.request_type_.auth_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.auth_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::RPC::AuthRequest& Request::_internal_auth_request() const {
  return _internal_has_auth_request()
      ? *_impl_.request_type_.auth_request_
      : reinterpret_cast< ::RPC::AuthRequest&>(::RPC::_AuthRequest_default_instance_);
}
inline const ::RPC::AuthRequest& Request::auth_request() const {
  // @@protoc_insertion_point(field_get:RPC.Request.auth_request)
  return _internal_auth_request();
}
inline ::RPC::AuthRequest* Request::unsafe_arena_release_auth_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:RPC.Request.auth_request)
  if (_internal_has_auth_request()) {
    clear_has_request_type();
    ::RPC::AuthRequest* temp = _impl_.request_type_.auth_request_;
    _impl_.request_type_.auth_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_auth_request(::RPC::AuthRequest* auth_request) {
  clear_request_type();
  if (auth_request) {
    set_has_auth_request();
    _impl_.request_type_.auth_request_ = auth_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RPC.Request.auth_request)
}
inline ::RPC::AuthRequest* Request::_internal_mutable_auth_request() {
  if (!_internal_has_auth_request()) {
    clear_request_type();
    set_has_auth_request();
    _impl_.request_type_.auth_request_ = CreateMaybeMessage< ::RPC::AuthRequest >(GetArenaForAllocation());
  }
  return _impl_.request_type_.auth_request_;
}
inline ::RPC::AuthRequest* Request::mutable_auth_request() {
  ::RPC::AuthRequest* _msg = _internal_mutable_auth_request();
  // @@protoc_insertion_point(field_mutable:RPC.Request.auth_request)
  return _msg;
}

// .RPC.FunctionRequest function_request = 2;
inline bool Request::_internal_has_function_request() const {
  return request_type_case() == kFunctionRequest;
}
inline bool Request::has_function_request() const {
  return _internal_has_function_request();
}
inline void Request::set_has_function_request() {
  _impl_._oneof_case_[0] = kFunctionRequest;
}
inline void Request::clear_function_request() {
  if (_internal_has_function_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.request_type_.function_request_;
    }
    clear_has_request_type();
  }
}
inline ::RPC::FunctionRequest* Request::release_function_request() {
  // @@protoc_insertion_point(field_release:RPC.Request.function_request)
  if (_internal_has_function_request()) {
    clear_has_request_type();
    ::RPC::FunctionRequest* temp = _impl_.request_type_.function_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.function_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::RPC::FunctionRequest& Request::_internal_function_request() const {
  return _internal_has_function_request()
      ? *_impl_.request_type_.function_request_
      : reinterpret_cast< ::RPC::FunctionRequest&>(::RPC::_FunctionRequest_default_instance_);
}
inline const ::RPC::FunctionRequest& Request::function_request() const {
  // @@protoc_insertion_point(field_get:RPC.Request.function_request)
  return _internal_function_request();
}
inline ::RPC::FunctionRequest* Request::unsafe_arena_release_function_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:RPC.Request.function_request)
  if (_internal_has_function_request()) {
    clear_has_request_type();
    ::RPC::FunctionRequest* temp = _impl_.request_type_.function_request_;
    _impl_.request_type_.function_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_function_request(::RPC::FunctionRequest* function_request) {
  clear_request_type();
  if (function_request) {
    set_has_function_request();
    _impl_.request_type_.function_request_ = function_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RPC.Request.function_request)
}
inline ::RPC::FunctionRequest* Request::_internal_mutable_function_request() {
  if (!_internal_has_function_request()) {
    clear_request_type();
    set_has_function_request();
    _impl_.request_type_.function_request_ = CreateMaybeMessage< ::RPC::FunctionRequest >(GetArenaForAllocation());
  }
  return _impl_.request_type_.function_request_;
}
inline ::RPC::FunctionRequest* Request::mutable_function_request() {
  ::RPC::FunctionRequest* _msg = _internal_mutable_function_request();
  // @@protoc_insertion_point(field_mutable:RPC.Request.function_request)
  return _msg;
}

inline bool Request::has_request_type() const {
  return request_type_case() != REQUEST_TYPE_NOT_SET;
}
inline void Request::clear_has_request_type() {
  _impl_._oneof_case_[0] = REQUEST_TYPE_NOT_SET;
}
inline Request::RequestTypeCase Request::request_type_case() const {
  return Request::RequestTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// FunctionRequest

// string function_name = 1;
inline void FunctionRequest::clear_function_name() {
  _impl_.function_name_.ClearToEmpty();
}
inline const std::string& FunctionRequest::function_name() const {
  // @@protoc_insertion_point(field_get:RPC.FunctionRequest.function_name)
  return _internal_function_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FunctionRequest::set_function_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.function_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RPC.FunctionRequest.function_name)
}
inline std::string* FunctionRequest::mutable_function_name() {
  std::string* _s = _internal_mutable_function_name();
  // @@protoc_insertion_point(field_mutable:RPC.FunctionRequest.function_name)
  return _s;
}
inline const std::string& FunctionRequest::_internal_function_name() const {
  return _impl_.function_name_.Get();
}
inline void FunctionRequest::_internal_set_function_name(const std::string& value) {
  
  _impl_.function_name_.Set(value, GetArenaForAllocation());
}
inline std::string* FunctionRequest::_internal_mutable_function_name() {
  
  return _impl_.function_name_.Mutable(GetArenaForAllocation());
}
inline std::string* FunctionRequest::release_function_name() {
  // @@protoc_insertion_point(field_release:RPC.FunctionRequest.function_name)
  return _impl_.function_name_.Release();
}
inline void FunctionRequest::set_allocated_function_name(std::string* function_name) {
  if (function_name != nullptr) {
    
  } else {
    
  }
  _impl_.function_name_.SetAllocated(function_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.function_name_.IsDefault()) {
    _impl_.function_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RPC.FunctionRequest.function_name)
}

// repeated .RPC.Argument args = 2;
inline int FunctionRequest::_internal_args_size() const {
  return _impl_.args_.size();
}
inline int FunctionRequest::args_size() const {
  return _internal_args_size();
}
inline void FunctionRequest::clear_args() {
  _impl_.args_.Clear();
}
inline ::RPC::Argument* FunctionRequest::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:RPC.FunctionRequest.args)
  return _impl_.args_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RPC::Argument >*
FunctionRequest::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:RPC.FunctionRequest.args)
  return &_impl_.args_;
}
inline const ::RPC::Argument& FunctionRequest::_internal_args(int index) const {
  return _impl_.args_.Get(index);
}
inline const ::RPC::Argument& FunctionRequest::args(int index) const {
  // @@protoc_insertion_point(field_get:RPC.FunctionRequest.args)
  return _internal_args(index);
}
inline ::RPC::Argument* FunctionRequest::_internal_add_args() {
  return _impl_.args_.Add();
}
inline ::RPC::Argument* FunctionRequest::add_args() {
  ::RPC::Argument* _add = _internal_add_args();
  // @@protoc_insertion_point(field_add:RPC.FunctionRequest.args)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RPC::Argument >&
FunctionRequest::args() const {
  // @@protoc_insertion_point(field_list:RPC.FunctionRequest.args)
  return _impl_.args_;
}

// string client_id = 3;
inline void FunctionRequest::clear_client_id() {
  _impl_.client_id_.ClearToEmpty();
}
inline const std::string& FunctionRequest::client_id() const {
  // @@protoc_insertion_point(field_get:RPC.FunctionRequest.client_id)
  return _internal_client_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FunctionRequest::set_client_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.client_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RPC.FunctionRequest.client_id)
}
inline std::string* FunctionRequest::mutable_client_id() {
  std::string* _s = _internal_mutable_client_id();
  // @@protoc_insertion_point(field_mutable:RPC.FunctionRequest.client_id)
  return _s;
}
inline const std::string& FunctionRequest::_internal_client_id() const {
  return _impl_.client_id_.Get();
}
inline void FunctionRequest::_internal_set_client_id(const std::string& value) {
  
  _impl_.client_id_.Set(value, GetArenaForAllocation());
}
inline std::string* FunctionRequest::_internal_mutable_client_id() {
  
  return _impl_.client_id_.Mutable(GetArenaForAllocation());
}
inline std::string* FunctionRequest::release_client_id() {
  // @@protoc_insertion_point(field_release:RPC.FunctionRequest.client_id)
  return _impl_.client_id_.Release();
}
inline void FunctionRequest::set_allocated_client_id(std::string* client_id) {
  if (client_id != nullptr) {
    
  } else {
    
  }
  _impl_.client_id_.SetAllocated(client_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.client_id_.IsDefault()) {
    _impl_.client_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RPC.FunctionRequest.client_id)
}

// string token = 4;
inline void FunctionRequest::clear_token() {
  _impl_.token_.ClearToEmpty();
}
inline const std::string& FunctionRequest::token() const {
  // @@protoc_insertion_point(field_get:RPC.FunctionRequest.token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FunctionRequest::set_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RPC.FunctionRequest.token)
}
inline std::string* FunctionRequest::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:RPC.FunctionRequest.token)
  return _s;
}
inline const std::string& FunctionRequest::_internal_token() const {
  return _impl_.token_.Get();
}
inline void FunctionRequest::_internal_set_token(const std::string& value) {
  
  _impl_.token_.Set(value, GetArenaForAllocation());
}
inline std::string* FunctionRequest::_internal_mutable_token() {
  
  return _impl_.token_.Mutable(GetArenaForAllocation());
}
inline std::string* FunctionRequest::release_token() {
  // @@protoc_insertion_point(field_release:RPC.FunctionRequest.token)
  return _impl_.token_.Release();
}
inline void FunctionRequest::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  _impl_.token_.SetAllocated(token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.token_.IsDefault()) {
    _impl_.token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RPC.FunctionRequest.token)
}

// -------------------------------------------------------------------

// Response

// .RPC.ReturnValue return_value = 1;
inline bool Response::_internal_has_return_value() const {
  return response_type_case() == kReturnValue;
}
inline bool Response::has_return_value() const {
  return _internal_has_return_value();
}
inline void Response::set_has_return_value() {
  _impl_._oneof_case_[0] = kReturnValue;
}
inline void Response::clear_return_value() {
  if (_internal_has_return_value()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.response_type_.return_value_;
    }
    clear_has_response_type();
  }
}
inline ::RPC::ReturnValue* Response::release_return_value() {
  // @@protoc_insertion_point(field_release:RPC.Response.return_value)
  if (_internal_has_return_value()) {
    clear_has_response_type();
    ::RPC::ReturnValue* temp = _impl_.response_type_.return_value_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.return_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::RPC::ReturnValue& Response::_internal_return_value() const {
  return _internal_has_return_value()
      ? *_impl_.response_type_.return_value_
      : reinterpret_cast< ::RPC::ReturnValue&>(::RPC::_ReturnValue_default_instance_);
}
inline const ::RPC::ReturnValue& Response::return_value() const {
  // @@protoc_insertion_point(field_get:RPC.Response.return_value)
  return _internal_return_value();
}
inline ::RPC::ReturnValue* Response::unsafe_arena_release_return_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:RPC.Response.return_value)
  if (_internal_has_return_value()) {
    clear_has_response_type();
    ::RPC::ReturnValue* temp = _impl_.response_type_.return_value_;
    _impl_.response_type_.return_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_return_value(::RPC::ReturnValue* return_value) {
  clear_response_type();
  if (return_value) {
    set_has_return_value();
    _impl_.response_type_.return_value_ = return_value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RPC.Response.return_value)
}
inline ::RPC::ReturnValue* Response::_internal_mutable_return_value() {
  if (!_internal_has_return_value()) {
    clear_response_type();
    set_has_return_value();
    _impl_.response_type_.return_value_ = CreateMaybeMessage< ::RPC::ReturnValue >(GetArenaForAllocation());
  }
  return _impl_.response_type_.return_value_;
}
inline ::RPC::ReturnValue* Response::mutable_return_value() {
  ::RPC::ReturnValue* _msg = _internal_mutable_return_value();
  // @@protoc_insertion_point(field_mutable:RPC.Response.return_value)
  return _msg;
}

// .RPC.AuthResponse auth_response = 2;
inline bool Response::_internal_has_auth_response() const {
  return response_type_case() == kAuthResponse;
}
inline bool Response::has_auth_response() const {
  return _internal_has_auth_response();
}
inline void Response::set_has_auth_response() {
  _impl_._oneof_case_[0] = kAuthResponse;
}
inline void Response::clear_auth_response() {
  if (_internal_has_auth_response()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.response_type_.auth_response_;
    }
    clear_has_response_type();
  }
}
inline ::RPC::AuthResponse* Response::release_auth_response() {
  // @@protoc_insertion_point(field_release:RPC.Response.auth_response)
  if (_internal_has_auth_response()) {
    clear_has_response_type();
    ::RPC::AuthResponse* temp = _impl_.response_type_.auth_response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.auth_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::RPC::AuthResponse& Response::_internal_auth_response() const {
  return _internal_has_auth_response()
      ? *_impl_.response_type_.auth_response_
      : reinterpret_cast< ::RPC::AuthResponse&>(::RPC::_AuthResponse_default_instance_);
}
inline const ::RPC::AuthResponse& Response::auth_response() const {
  // @@protoc_insertion_point(field_get:RPC.Response.auth_response)
  return _internal_auth_response();
}
inline ::RPC::AuthResponse* Response::unsafe_arena_release_auth_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:RPC.Response.auth_response)
  if (_internal_has_auth_response()) {
    clear_has_response_type();
    ::RPC::AuthResponse* temp = _impl_.response_type_.auth_response_;
    _impl_.response_type_.auth_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_auth_response(::RPC::AuthResponse* auth_response) {
  clear_response_type();
  if (auth_response) {
    set_has_auth_response();
    _impl_.response_type_.auth_response_ = auth_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RPC.Response.auth_response)
}
inline ::RPC::AuthResponse* Response::_internal_mutable_auth_response() {
  if (!_internal_has_auth_response()) {
    clear_response_type();
    set_has_auth_response();
    _impl_.response_type_.auth_response_ = CreateMaybeMessage< ::RPC::AuthResponse >(GetArenaForAllocation());
  }
  return _impl_.response_type_.auth_response_;
}
inline ::RPC::AuthResponse* Response::mutable_auth_response() {
  ::RPC::AuthResponse* _msg = _internal_mutable_auth_response();
  // @@protoc_insertion_point(field_mutable:RPC.Response.auth_response)
  return _msg;
}

inline bool Response::has_response_type() const {
  return response_type_case() != RESPONSE_TYPE_NOT_SET;
}
inline void Response::clear_has_response_type() {
  _impl_._oneof_case_[0] = RESPONSE_TYPE_NOT_SET;
}
inline Response::ResponseTypeCase Response::response_type_case() const {
  return Response::ResponseTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// AuthRequest

// string client_id = 1;
inline void AuthRequest::clear_client_id() {
  _impl_.client_id_.ClearToEmpty();
}
inline const std::string& AuthRequest::client_id() const {
  // @@protoc_insertion_point(field_get:RPC.AuthRequest.client_id)
  return _internal_client_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AuthRequest::set_client_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.client_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RPC.AuthRequest.client_id)
}
inline std::string* AuthRequest::mutable_client_id() {
  std::string* _s = _internal_mutable_client_id();
  // @@protoc_insertion_point(field_mutable:RPC.AuthRequest.client_id)
  return _s;
}
inline const std::string& AuthRequest::_internal_client_id() const {
  return _impl_.client_id_.Get();
}
inline void AuthRequest::_internal_set_client_id(const std::string& value) {
  
  _impl_.client_id_.Set(value, GetArenaForAllocation());
}
inline std::string* AuthRequest::_internal_mutable_client_id() {
  
  return _impl_.client_id_.Mutable(GetArenaForAllocation());
}
inline std::string* AuthRequest::release_client_id() {
  // @@protoc_insertion_point(field_release:RPC.AuthRequest.client_id)
  return _impl_.client_id_.Release();
}
inline void AuthRequest::set_allocated_client_id(std::string* client_id) {
  if (client_id != nullptr) {
    
  } else {
    
  }
  _impl_.client_id_.SetAllocated(client_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.client_id_.IsDefault()) {
    _impl_.client_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RPC.AuthRequest.client_id)
}

// string client_secret = 2;
inline void AuthRequest::clear_client_secret() {
  _impl_.client_secret_.ClearToEmpty();
}
inline const std::string& AuthRequest::client_secret() const {
  // @@protoc_insertion_point(field_get:RPC.AuthRequest.client_secret)
  return _internal_client_secret();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AuthRequest::set_client_secret(ArgT0&& arg0, ArgT... args) {
 
 _impl_.client_secret_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RPC.AuthRequest.client_secret)
}
inline std::string* AuthRequest::mutable_client_secret() {
  std::string* _s = _internal_mutable_client_secret();
  // @@protoc_insertion_point(field_mutable:RPC.AuthRequest.client_secret)
  return _s;
}
inline const std::string& AuthRequest::_internal_client_secret() const {
  return _impl_.client_secret_.Get();
}
inline void AuthRequest::_internal_set_client_secret(const std::string& value) {
  
  _impl_.client_secret_.Set(value, GetArenaForAllocation());
}
inline std::string* AuthRequest::_internal_mutable_client_secret() {
  
  return _impl_.client_secret_.Mutable(GetArenaForAllocation());
}
inline std::string* AuthRequest::release_client_secret() {
  // @@protoc_insertion_point(field_release:RPC.AuthRequest.client_secret)
  return _impl_.client_secret_.Release();
}
inline void AuthRequest::set_allocated_client_secret(std::string* client_secret) {
  if (client_secret != nullptr) {
    
  } else {
    
  }
  _impl_.client_secret_.SetAllocated(client_secret, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.client_secret_.IsDefault()) {
    _impl_.client_secret_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RPC.AuthRequest.client_secret)
}

// int32 uid = 3;
inline void AuthRequest::clear_uid() {
  _impl_.uid_ = 0;
}
inline int32_t AuthRequest::_internal_uid() const {
  return _impl_.uid_;
}
inline int32_t AuthRequest::uid() const {
  // @@protoc_insertion_point(field_get:RPC.AuthRequest.uid)
  return _internal_uid();
}
inline void AuthRequest::_internal_set_uid(int32_t value) {
  
  _impl_.uid_ = value;
}
inline void AuthRequest::set_uid(int32_t value) {
  _internal_set_uid(value);
  // @@protoc_insertion_point(field_set:RPC.AuthRequest.uid)
}

// int32 gid = 4;
inline void AuthRequest::clear_gid() {
  _impl_.gid_ = 0;
}
inline int32_t AuthRequest::_internal_gid() const {
  return _impl_.gid_;
}
inline int32_t AuthRequest::gid() const {
  // @@protoc_insertion_point(field_get:RPC.AuthRequest.gid)
  return _internal_gid();
}
inline void AuthRequest::_internal_set_gid(int32_t value) {
  
  _impl_.gid_ = value;
}
inline void AuthRequest::set_gid(int32_t value) {
  _internal_set_gid(value);
  // @@protoc_insertion_point(field_set:RPC.AuthRequest.gid)
}

// -------------------------------------------------------------------

// AuthResponse

// .RPC.Status status = 1;
inline void AuthResponse::clear_status() {
  _impl_.status_ = 0;
}
inline ::RPC::Status AuthResponse::_internal_status() const {
  return static_cast< ::RPC::Status >(_impl_.status_);
}
inline ::RPC::Status AuthResponse::status() const {
  // @@protoc_insertion_point(field_get:RPC.AuthResponse.status)
  return _internal_status();
}
inline void AuthResponse::_internal_set_status(::RPC::Status value) {
  
  _impl_.status_ = value;
}
inline void AuthResponse::set_status(::RPC::Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:RPC.AuthResponse.status)
}

// string token = 2;
inline void AuthResponse::clear_token() {
  _impl_.token_.ClearToEmpty();
}
inline const std::string& AuthResponse::token() const {
  // @@protoc_insertion_point(field_get:RPC.AuthResponse.token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AuthResponse::set_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RPC.AuthResponse.token)
}
inline std::string* AuthResponse::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:RPC.AuthResponse.token)
  return _s;
}
inline const std::string& AuthResponse::_internal_token() const {
  return _impl_.token_.Get();
}
inline void AuthResponse::_internal_set_token(const std::string& value) {
  
  _impl_.token_.Set(value, GetArenaForAllocation());
}
inline std::string* AuthResponse::_internal_mutable_token() {
  
  return _impl_.token_.Mutable(GetArenaForAllocation());
}
inline std::string* AuthResponse::release_token() {
  // @@protoc_insertion_point(field_release:RPC.AuthResponse.token)
  return _impl_.token_.Release();
}
inline void AuthResponse::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  _impl_.token_.SetAllocated(token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.token_.IsDefault()) {
    _impl_.token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RPC.AuthResponse.token)
}

// string message = 3;
inline void AuthResponse::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& AuthResponse::message() const {
  // @@protoc_insertion_point(field_get:RPC.AuthResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AuthResponse::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RPC.AuthResponse.message)
}
inline std::string* AuthResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:RPC.AuthResponse.message)
  return _s;
}
inline const std::string& AuthResponse::_internal_message() const {
  return _impl_.message_.Get();
}
inline void AuthResponse::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* AuthResponse::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* AuthResponse::release_message() {
  // @@protoc_insertion_point(field_release:RPC.AuthResponse.message)
  return _impl_.message_.Release();
}
inline void AuthResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RPC.AuthResponse.message)
}

// int64 session_expiry = 4;
inline void AuthResponse::clear_session_expiry() {
  _impl_.session_expiry_ = int64_t{0};
}
inline int64_t AuthResponse::_internal_session_expiry() const {
  return _impl_.session_expiry_;
}
inline int64_t AuthResponse::session_expiry() const {
  // @@protoc_insertion_point(field_get:RPC.AuthResponse.session_expiry)
  return _internal_session_expiry();
}
inline void AuthResponse::_internal_set_session_expiry(int64_t value) {
  
  _impl_.session_expiry_ = value;
}
inline void AuthResponse::set_session_expiry(int64_t value) {
  _internal_set_session_expiry(value);
  // @@protoc_insertion_point(field_set:RPC.AuthResponse.session_expiry)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace RPC

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::RPC::Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RPC::Status>() {
  return ::RPC::Status_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_procedure_5fformat_2eproto
